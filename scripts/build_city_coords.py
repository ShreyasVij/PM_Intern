#!/usr/bin/env python3
"""
Build backend/city_coords.py from data/cities.in.json

Input JSON format (array of objects):
[
  {"city": "Mumbai", "lat": 19.0760, "lon": 72.8777, "aliases": ["Bombay"]},
  {"city": "Navi Mumbai", "lat": 19.0330, "lon": 73.0297}
]

Output: backend/city_coords.py module with CITY_COORDINATES and DISPLAY_NAMES.
"""
import json
import os
from typing import Dict, Tuple, List

ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DATA_PATH = os.path.join(ROOT, 'data', 'cities.in.json')
OUT_PATH = os.path.join(ROOT, 'backend', 'city_coords.py')


def normalize_key(name: str) -> str:
    return ' '.join((name or '').strip().lower().split())


def load_cities() -> List[dict]:
    with open(DATA_PATH, 'r', encoding='utf-8') as f:
        data = json.load(f)
    if not isinstance(data, list):
        raise ValueError('cities.in.json must be a list of objects')
    cleaned = []
    seen = set()
    for item in data:
        city = (item.get('city') or '').strip()
        if not city:
            continue
        try:
            lat = float(item.get('lat'))
            lon = float(item.get('lon'))
        except Exception:
            continue
        key = normalize_key(city)
        if key in seen:
            # keep first occurrence; you can enhance with population or priority later
            continue
        seen.add(key)
        aliases = [str(a).strip() for a in (item.get('aliases') or []) if str(a).strip()]
        cleaned.append({'key': key, 'city': city, 'lat': lat, 'lon': lon, 'aliases': aliases})
    return cleaned


def write_module(rows: List[dict]) -> None:
    header = (
        '"""\n'
        'Static coordinates for Indian cities and display names.\n\n'
        'This file is generated by scripts/build_city_coords.py from data/cities.in.json\n'
        '"""\n\n'
    )
    # CITY_COORDINATES
    coord_lines = ["CITY_COORDINATES: dict[str, tuple[float, float]] = {"]
    for r in rows:
        coord_lines.append(f"    {r['key']!r}: ({r['lat']:.6f}, {r['lon']:.6f}),")
    coord_lines.append("}\n")

    # DISPLAY_NAMES maps key -> original display city
    disp_lines = ["DISPLAY_NAMES: dict[str, str] = {"]
    for r in rows:
        disp_lines.append(f"    {r['key']!r}: {r['city']!r},")
    disp_lines.append("}\n")

    util = (
        "def get_all_display_cities_sorted() -> list[str]:\n"
        "    return sorted(DISPLAY_NAMES.values())\n"
    )

    content = header + "\n".join(coord_lines) + "\n" + "\n".join(disp_lines) + "\n" + util + "\n"
    os.makedirs(os.path.dirname(OUT_PATH), exist_ok=True)
    with open(OUT_PATH, 'w', encoding='utf-8') as f:
        f.write(content)


def main():
    rows = load_cities()
    if not rows:
        raise SystemExit('No valid cities found in data/cities.in.json')
    write_module(rows)
    print(f"Wrote {len(rows)} cities to {OUT_PATH}")


if __name__ == '__main__':
    main()
